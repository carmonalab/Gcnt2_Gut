---
title: "Cell Clustering and Classification"
author: A. Mihaylov <aleksandar.mihaylov@epfl.ch>
---

# Downloading Processed Dataset

```{r downloading_processed_dataset}
library(dplyr)

ds_name <- "SalasA_2023_GSE214695"
home.path <- file.path(getwd(), ds_name)
output_data_path <- file.path(home.path, "output")

size <- "whole" # "light" or "whole"

# cmc stands for colonic mucosa cells
cmc <- readRDS(file.path(output_data_path, paste0(ds_name, sprintf("_%s.rds", size))))
```

# Finding Variable Genes

This section finds the 2000 most variable genes across the cells in the dataset.

We can vary the selection method: "vst", "mean.var.plot", and "dispersion". "mean.var.plot" does 
not work and demands the empirical determination of two more parameters, namely "num.bin" and
"binning.method".

```{r find_var_genes}
cmc <- Seurat::FindVariableFeatures(cmc, selection.method = "dispersion", nfeatures = 2000)

top_5 <- head(SeuratObject::VariableFeatures(cmc), 5)
plot_1 <- Seurat::VariableFeaturePlot(cmc)
plot_1 <- Seurat::LabelPoints(plot = plot_1, points = top_5, repel = TRUE, xnudge = 0, ynudge = 0)
plot_1 + ggplot2::ggtitle("Variable Feature Plot for Colonic Mucosa Cells")
```

# Scaling the Data

This step scales gene expression, to a normal distributions, across cells such that downstream 
analyses are not biased by highly-expressed genes.

Let us also play around with the "vars.to.regress" parameter. We can decide to include "percent.mito"
and/or "percent.ribo"

```{r scale_data}
cmc <- Seurat::ScaleData(cmc, vars.to.regress = c("percent.mito", "percent.ribo"))
```

```{r saving_scaled}
saveRDS(cmc, file.path(output_data_path,paste0(ds_name,sprintf("_scaled_%s.rds", size))))
```


# Principal Component Analysis (PCA)

## Running PCA

```{r pca}
cmc <- Seurat::RunPCA(cmc, features = SeuratObject::VariableFeatures(cmc), verbose = FALSE, 
                      seed.use = 42)
```

## Visualizing and Examining PCAs

We begin by examining the loadings of the first 5 PCs.

```{r pca_loadings}
print(cmc[["pca"]], dims = 1:6, nfeatures = 5)

Seurat::VizDimLoadings(cmc, dims = 1:2, nfeatures = 15)
Seurat::VizDimLoadings(cmc, dims = 3:4, nfeatures = 15)
Seurat::VizDimLoadings(cmc, dims = 5:6, nfeatures = 15)
```

Then, we look at the **Dimension Plot** to visualize how the first two PCs separate the cells 
in our dataset.

```{r dim_plot}
Seurat::DimPlot(cmc, dims = c(1, 2), reduction = "pca") + 
  ggplot2::ggtitle("Cell Distribution across PCs 1 and 2")
```

Finally, let us vsiaulize the PCs in a Dimensional Heatmap.

```{r dim_heatmap, fig.height=20, fig.show='hold'}
Seurat::DimHeatmap(cmc, dims = 1:9, cells = 1000, balanced = TRUE)
Seurat::DimHeatmap(cmc, dims = 10:18, cells = 1000, balanced = TRUE)
```

## Dimensionality of thhe Dataset

We use the **Elbow plot** and thus the **Elbow method** to determine how many PCs we 
keep for downstream analyses. 

```{r elbow_plot}
Seurat::ElbowPlot(cmc, ndims = 32) +
  ggplot2::ggtitle("Elbow Plot for PCs 1 through 32")
```

Since it is better to err on the higher side of chosen PCs, we will use 15 dimensions 
for all downstream analyses.

# Cell Clustering

## Graph Clustering (KNN)

Let us see how many cell types the author has at the end of his clustering to better choose
our resolution parameter.

```{r}
author_annotations <- data.table::fread(file.path(ds_name, "data/GSE214695/GSE214695_cell_annotation.csv.gz"), header = TRUE)
cat("Number of distinct cell types in author's annotations:", length(unique(author_annotations$annotation)))
```

For the clustering, we use the Leiden algorithm and various resolutions: 0.3, 0.6, and 0.8.

```{r graph_clustering}
cmc <- Seurat::FindNeighbors(cmc, dims = 1:15)
cmc <- Seurat::FindClusters(cmc, resolution = c(0.3, 0.6, 0.8), algorithm = 4, random.seed = 42)
```

```{r saving_clustered}
saveRDS(cmc, file.path(output_data_path,paste0(ds_name,sprintf("_clustered_%s.rds", size))))
```

UMAP for resolution equal to 0.8.

```{r umap_res_1}
Seurat::Idents(cmc) <- "RNA_snn_res.0.8"
cmc <- Seurat::RunUMAP(cmc, dims = 1:15, seed.use = 42)
Seurat::DimPlot(cmc, reduction = "umap", label = TRUE) +
  ggplot2::ggtitle("Umap of KNN Clustering with 0.8 Resolution")
```

UMAP for resolution equal to 0.6.


```{r umap_res_2}
Seurat::Idents(cmc) <- "RNA_snn_res.0.6"
cmc <- Seurat::RunUMAP(cmc, dims = 1:15, seed.use = 42)
Seurat::DimPlot(cmc, reduction = "umap", label = TRUE) +
  ggplot2::ggtitle("Umap of KNN Clustering with 0.6 Resolution")
```

UMAP for resolution equal to 0.3.


```{r umap_res_3}
Seurat::Idents(cmc) <- "RNA_snn_res.0.3"
cmc <- Seurat::RunUMAP(cmc, dims = 1:15, seed.use = 42)
Seurat::DimPlot(cmc, reduction = "umap", label = TRUE) +
  ggplot2::ggtitle("Umap of KNN Clustering with 0.3 Resolution")
```

For downstream analyses, we choose the resolution of 0.3.

```{r res}
res <- 0.3
Seurat::Idents(cmc) <- sprintf("RNA_snn_res.%.1f", res)
```

# Differentially Expressed Genes

## Identifying Positive Differentially Expressed Genes per Cluster

Below, we seek to find the positive differentially expressed genes for a given cluster. The top positive differentially expressed genes per cluster will enable the cluster annotation.

```{r find_DE}
for (i in unique(Seurat::Idents(cmc))){
  cluster.markers <- sprintf("cluster%.0f.markers", as.integer(i))
  assign(cluster.markers, Seurat::FindMarkers(cmc, ident.1 = as.integer(i), test.use = "wilcox", 
                                              only.pos = TRUE, max.cells.per.ident = Inf,
                                              random.seed = 42))
}
```

The cell below displays the positive differentially expressed genes per cluster.

```{r display_DE}
for (i in unique(Seurat::Idents(cmc))){
  cat(i, "\n")
  df <- get(sprintf("cluster%d.markers", as.integer(i)))
  print(df)
}
```

Now, we find the positive differentially expressed genes for all clusters.

```{r find_all_markers}
cmc.markers <- Seurat::FindAllMarkers(cmc, test.use = "wilcox", only.pos = TRUE,
                                      max.cells.per.ident = Inf, random.seed = 42)
```

```{r saving_DE}
saveRDS(cmc, file.path(output_data_path,paste0(ds_name,sprintf("_de_%s.rds", size))))
```

## Visualizing Top Differentially Expressed Genes across Clusters

Let us first create violin plots for the top 4 positive differentially expressed genes per cluster. The violin plots will then illustrate how these genes vary across clusters. 

```{r violin_plots_DE}
for (i in unique(Seurat::Idents(cmc))){
  cluster_of_interest <- get(sprintf("cluster%.0f.markers", as.integer(i)))
  top_4_DE_genes <- rownames(head(cluster_of_interest, 4))
  plots <- lapply(top_4_DE_genes, function(gene) {
  Seurat::VlnPlot(cmc, features = gene) + ggplot2::xlab("Clusters") + Seurat::NoLegend() +
      ggplot2::ggtitle(paste(gene, "Cluster", i))
  })
  combined <- patchwork::wrap_plots(plots, ncol = 2)
  print(combined)
}
```

Next, we display feature plots for each cluster's top positive differentially expressed gene. These plots will help us visualize how restricted the expression of these top positive differentially expressed genes is to their cluster.


```{r summary_feature_plot_DE, fig.height=16, fig.width=9}
top_DE_genes <- c()

for (i in unique(Seurat::Idents(cmc))){
  cluster_of_interest <- get(sprintf("cluster%.0f.markers", as.integer(i)))
  top_1_DE_gene <- rownames(head(cluster_of_interest, 1))
  top_DE_genes[[i]] <- top_1_DE_gene
}

plots <- mapply(function(gene, key){
  Seurat::FeaturePlot(cmc, features = gene) + Seurat::NoLegend() +
    ggplot2::ggtitle(paste(gene, "Cluster", key))
}, gene = top_DE_genes, key = names(top_DE_genes), SIMPLIFY = FALSE)
combined <- patchwork::wrap_plots(plots, ncol = 3, nrow = 5)
print(combined)
```

```{r feature_plots}
for (i in unique(Seurat::Idents(cmc))){
  cluster_of_interest <- get(sprintf("cluster%.0f.markers", as.integer(i)))
  print(Seurat::FeaturePlot(cmc, features = top_DE_genes[[as.integer(i)]]) + ggplot2::ggtitle(paste(top_DE_genes[[as.integer(i)]], "Cluster", i)))
}
```


Finally, we display an expression heatmap for the top 10 markers for each cluster.

```{r heatmap_DE}
cmc.markers %>%
  group_by(cluster) %>%
  filter(avg_log2FC > 1) %>%
  arrange(p_val_adj) %>%
  slice_head(n = 10) %>%
  ungroup() -> top10
Seurat::DoHeatmap(cmc, features = top10$gene) + Seurat::NoLegend() +
  ggplot2::ggtitle("Expression Heatmap across Cells of Top Differentially Expressed 
                   Genes per Cluster")
```

# Cluster Annotation

## Further Investigations 

When ordered by p-value, the top positive differentially expressed genes for cluster 14 are mitochondrial genes. Thus, we are wondering whether this cluster represents low quality cells that have slipped through our quality control. 

```{r cluster_14}
Seurat::VlnPlot(cmc, features = "percent.mito") + Seurat::NoLegend()

cmc$cluster_14 = ifelse(Seurat::Idents(cmc) == "14", "Cluster 14", "Other")

Seurat::VlnPlot(cmc, features = "percent.mito", cols = c("Cluster 14" = "blue", "Other" = "lightgrey"), group.by = "cluster_14")

Seurat::FeatureScatter(cmc, feature1 = "nCount_RNA", feature2 = "nFeature_RNA", group.by = "cluster_14") +
  ggplot2::scale_color_manual(values = c("Cluster 14" = "blue", "Other" = "lightgrey")) + 
  ggplot2::ggtitle("Number of Features vs. Number of Counts")
```

From the above plots, one can see that cluster 14 has low RNA and feature counts but an elevated mitochondrial content.

```{r DE_genes_cluster_14}
cluster14.markers %>%
  filter(p_val_adj < 0.05) %>%
  arrange(desc(avg_log2FC)) -> cluster14.markers.logFC

cluster14.markers.logFC
```

Moreover, when ordered by avg_log2FC, the top positive differentially expressed genes for cluster 14 do not point towards any plausible cell type found in the colonic mucosa. Hence, cluster 14 is probably filled with low quality cells that we will discard. That is, we will subset our Seurat object so that the cells of cluster 14 do not appear in downstream analyses.

```{r deleting_cluster_14}
cured_cmc <- subset(cmc, subset = cluster_14 != "Cluster 14")

cmc$cluster_14 <- NULL
cured_cmc$cluster_14 <- NULL

cat("Number of cells left in Seurat object:", length(Seurat::Cells(cured_cmc)))
```

## scGate Classification

```{r scGate_model}
models.DB <- scGate::get_scGateDB()
models.list <- models.DB$human
gating_model <- models.list$HiTME
cured_cmc <- scGate::scGate(cured_cmc, model = gating_model, ncores = 1, seed = 42)
table(cured_cmc$scGate_multi, useNA = "ifany")
```

```{r saving_gated}
saveRDS(cured_cmc, file.path(output_data_path,paste0(ds_name,sprintf("_gated_%s.rds", size))))
```

Let us quickly visualize the obtained scGate classification on our Umap.

```{r scGate_classification_plot}
Seurat::DimPlot(cured_cmc, reduction = "umap", group.by = "scGate_multi", label = TRUE, repel = TRUE) +
  ggplot2::ggtitle("scGate Cell Annotation")
```

Now, we create a stacked barplot to analyze which cell types, obtained from the scGate classification, the clusters map to.

```{r classification_to_cluster}
Seurat::Idents(cured_cmc) <- sprintf("RNA_snn_res.%.1f", res)

dittoSeq::dittoBarPlot(
    object = cured_cmc,
    var = Seurat::Idents(cured_cmc),
    group.by = "scGate_multi") +
  ggplot2::ggtitle("Stacked Bar Plot of Cluster Representation across Cell Types")

dittoSeq::dittoBarPlot(
    object = cured_cmc,
    var = "scGate_multi",
    group.by = Seurat::Idents(cured_cmc)) +
  ggplot2::ggtitle("Stacked Bar Plot of Cell Type Representation across Clusters") +
  ggplot2::xlab("Clusters")

frequency.mat <- table(Seurat::Idents(cured_cmc), cured_cmc$scGate_multi)
frequency.mat <- apply(frequency.mat, 1, function(x) {
  x*100/sum(x)
})
frequency.mat <- t(frequency.mat)
frequency.df <- as.data.frame.matrix(frequency.mat)
print(frequency.df)

frequency.melted <- reshape2::melt(frequency.mat, varnames = c("Cluster", "CellType"), value.name = "Percentage")
frequency.melted$Cluster <- factor(frequency.melted$Cluster,
                                   levels = unique(frequency.melted$Cluster))

ggplot2::ggplot(frequency.melted, ggplot2::aes(x = Cluster, y = CellType, fill = Percentage)) +
  ggplot2::geom_tile() +
  ggplot2::labs(title = "Heatmap of Cell Type per Cluster",
                x = "Cluster",
                y = "Cell Type")
```

## Manual Annotation

Manually, we label each cluster with the cell type that is most represented within the cluster. The most represented cell type for each cluster can be found in the table, barplot, and heatmap above.

```{r manual_annotation}
cured_cmc$manual_annotation <- NA

for (i in unique(Seurat::Idents(cured_cmc))) {
  cluster_row <- frequency.df[as.character(i), ]
  cell_type <- names(which.max(cluster_row))

  cluster_cells <- Seurat::WhichCells(cured_cmc, idents = i)
  cured_cmc$manual_annotation[cluster_cells] <- cell_type
}
```

Finally, let us save our final Seurat object that has been scGated and manually annotated.

```{r saving_annotated}
saveRDS(cured_cmc, file.path(output_data_path,paste0(ds_name,sprintf("_annotated_%s.rds", size))))
```

## Quality Control of Manual Annotation

```{r annotation_qc, fig.height = 16}
qc_markers <- c("MS4A1", "CD79A", "FOXN1", "KRT15", "RAMP3", "CLDN5", "COL1A1", "COL1A2",
                "JCHAIN", "MZB1", "TPSAB1", "TPSB2", "GZMK", "CD4", "CD8A", "CD8B", "C1QC", "TYROBP")

Seurat::Idents(cured_cmc) <- "manual_annotation"
Seurat::VlnPlot(cured_cmc, features = qc_markers, stack = T, flip = T, fill.by = "ident",
    assay = "RNA") + Seurat::NoLegend() + 
  ggplot2::ggtitle("Annotation Quality Control Violin Plots of Marker Genes") +
  ggplot2::xlab("Cell Type")
```






